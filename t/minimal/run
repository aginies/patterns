#!/usr/bin/perl

use strict;
use solv;
use Data::Dump;

use Getopt::Long;
my %options;
Getopt::Long::Configure("no_ignore_case");
GetOptions (
	\%options,
	"explain",
	"list",
	"size",
	"no-recommends",
	"arch=s",
	"packs=s@",
	"repo=s@",
) or die "invalid arguments\n";

$options{'repo'} = [ split(/,/, join(',', @{$options{'repo'}})) ] if $options{'repo'};
$options{'packs'} = [ split(/,/, join(',', @{$options{'packs'}})) ] if $options{'packs'};
$options{'size'} = 1 unless ($options{'explain'} || $options{'list'});

unless ($options{'arch'}) {
	my $arch = 'x86_64';
	warn "--arch not specified, assuming $arch\n";
	$options{'arch'} = $arch;
}

my $pool = solv::Pool->new();
$pool->set_debuglevel(1);
$pool->setarch ($options{'arch'});

my %repos;
for my $name (@{$options{'repo'}}) {
	my $repo = $pool->add_repo($name);
	$repo->add_solv ($name.'.solv');
	$repos{$name} = $repo;
}

dd \%repos;

$pool->addfileprovides();
# will segfault if you don't do that!
$pool->createwhatprovides();

# Create Solver
my $solver = $pool->Solver();

# Create Request
#my $job = $pool->create_request();
my @jobs;

for my $p (@{$options{'packs'}}) {
	my ($n, $r) = split(/@/, $p, 2);
#	$r = $pool->find_repo($r) if $r;
#	my $pat = $pool->find($n, $r) || die "Failed to push job: $p";
#	$job->install($pat);
	print "select $p $n $r\n";
	my $sel = $pool->select($n, $solv::Selection::SELECTION_NAME);
	$sel->filter($repos{$r}->Selection()) if $r;
	die "can't find $p\n" if $sel->isempty();
	for my $s ($sel->solvables()) {
		dd $s->str;
	}
	my @jj = $sel->jobs($solv::Job::SOLVER_INSTALL);
	for my $j (@jj) {
		dd $j->str;
		push @jobs, $j;
	}
}

#$solver->set_dont_install_recommended(1) if $options{'no-recommends'};
# Solve the jobs
$solver->set_flag($solv::Solver::SOLVER_FLAG_IGNORE_RECOMMENDED, 1) if $options{'no-recommends'};
my @problems = $solver->solve(\@jobs);

dd \@problems;

my $trans = $solver->transaction();

#if ($options{'explain'}) {
#	for my $d ($solver->decisions()) {
#		printf "%s %s\n", $d->op_s(), $d->solvable()->attr_values("solvable:name");;
#		my $ri = $d->ruleinfo($job);
#		if ($ri) {
#			printf "  %s\n", $ri->string();
#		}
#	}
#}
#
## Problems
#my $pc = $solver->problems_count();
#if ($pc) {
#    print "Found $pc problems\n";
#	my @problems = $solver->problems ($job);
#	for my $p (@problems) {
#	        my $ps = $p->string();
#		print "Problem $ps\n";
#	        my @solutions = $p->solutions();
#	        for my $s (@solutions) {
#		    my $ss = $s->string();
#		    print "  Solution $ss\n";
#		}
#	}
#	exit(1);
#}

sub sortbysize
{
	my $sa = $a->lookup_num($solv::SOLVABLE_INSTALLSIZE) || 0;
	my $sb = $b->lookup_num($solv::SOLVABLE_INSTALLSIZE) || 0;
	my $ret = $sa <=> $sb;
	unless ($ret) {
		$sa = $a->{"name"} || "";
		$sb = $b->{"name"} || "";
		$ret = $sa cmp $sb;
	}
	return $ret;
}

sub sortbyname
{
	my $sa = $a->{"name"} || "";
	my $sb = $b->{"name"} || "";
	$sa cmp $sb;
}

# Print packages to install
my @a = $trans->newsolvables();

if ($options{'list'}) {
	for my $solvable (sort sortbyname @a) {
		my $name = $solvable->{"name"};
		printf "%s\n", $name;
	}
} elsif ($options{'size'}) {
	for my $solvable (sort sortbysize @a) {
		my $name = $solvable->{"name"};
		my $arch = $solvable->{"arch"};
		my $ver  = $solvable->{"evr"};
		my $size = $solvable->lookup_num($solv::SOLVABLE_INSTALLSIZE) || 0;
		printf "%8d %s\n", $size/1024, $name;
	}
}

if ($options{'size'}) {
	# get install size

	my $size = $trans->calc_installsizechange();

	printf "%8d %s\n", $size, "TOTAL";
}

# my $transaction = $solver->transaction();
# my $sizechange = $transaction->sizechange();
# print "SIZE CHANGE: $sizechange kB\n";
